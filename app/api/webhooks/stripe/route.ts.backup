import { NextResponse } from 'next/server'
import { headers } from 'next/headers'
import { createServerClient } from '@supabase/ssr'
import Stripe from 'stripe'

// Initialize the Stripe client with your secret key
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || 'sk_test_placeholder', {
  apiVersion: '2022-11-15',
})

// This is your Stripe CLI webhook secret for testing your endpoint locally
const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET || 'whsec_placeholder'

export async function POST(request: Request) {
  // Log that we received a webhook request
  console.log('⭐ Stripe webhook received - starting processing');
  
  const payload = await request.text()
  const sig = headers().get('Stripe-Signature') || ''
  
  let event: Stripe.Event
  
  try {
    // Log webhook details for debugging
    console.log(`Webhook received: Signature: ${sig ? 'Present' : 'Missing'}, Secret: ${endpointSecret ? 'Present' : 'Missing'}`)
    console.log(`Webhook payload length: ${payload.length} characters`)
  // Log the event type from the payload
  try {
    const payloadObj = JSON.parse(payload)
    console.log(`Event type from payload: ${payloadObj.type}`)
  } catch (e) {
    console.log('Could not parse payload JSON')
  }
    
    // Verify the event came from Stripe using the webhook secret
    event = stripe.webhooks.constructEvent(payload, sig, endpointSecret)
  } catch (err) {
    const error = err as Error
    console.error(`⚠️  Webhook signature verification failed: ${error.message}`)
    console.error(`⚠️  Check that STRIPE_WEBHOOK_SECRET is correctly set in your environment variables`)
    return NextResponse.json({ error: `Webhook signature verification failed: ${error.message}` }, { status: 400 })
  }
  
  console.log(`✅ Success: Received Stripe webhook: ${event.type}`)
  
  // Handle the event based on its type
  try {
    switch (event.type) {
      case 'payment_intent.succeeded':
        const paymentIntent = event.data.object as Stripe.PaymentIntent
        console.log(`💰 PaymentIntent successful: ${paymentIntent.id}`)
        // You might want to fulfill the order here
        break
        
      case 'payment_intent.payment_failed':
        const failedPaymentIntent = event.data.object as Stripe.PaymentIntent
        console.log(`❌ PaymentIntent failed: ${failedPaymentIntent.id}`)
        break
        
      case 'checkout.session.completed':
        const session = event.data.object as Stripe.Checkout.Session
        console.log(`🛒 Checkout session completed: ${session.id}`)
        console.log('DEBUGGING SESSION DATA:', JSON.stringify(session, null, 2))
        console.log('FULL SESSION DATA FOR DEBUGGING:', JSON.stringify(session, null, 2))
        console.log('SESSION ID:', session.id)
        console.log('SESSION METADATA:', session.metadata)
        
        // Emergency direct insertion - will run regardless of other code
        try {
          const emergencyOrderData = {
            stripe_session_id: session.id,
            customer_email: session.customer_details?.email || 'tekthree+guestlist@gmail.com',
            customer_name: session.customer_details?.name || 'Emergency Insert',
            amount_total: session.amount_total ? session.amount_total / 100 : 25,
            status: 'completed',
            quantity: 1
          };
          
          console.log('EMERGENCY INSERTION ATTEMPT:', emergencyOrderData);
          console.log('Supabase URL:', process.env.NEXT_PUBLIC_SUPABASE_URL ? 'Present' : 'Missing');
          console.log('Supabase Service Key:', process.env.SUPABASE_SERVICE_ROLE_KEY ? 'Present (starts with ' + process.env.SUPABASE_SERVICE_ROLE_KEY.substring(0, 5) + '...)' : 'Missing');
          console.log('Supabase URL:', process.env.NEXT_PUBLIC_SUPABASE_URL ? 'Present' : 'Missing');
          console.log('Supabase Service Key:', process.env.SUPABASE_SERVICE_ROLE_KEY ? 'Present (starts with ' + process.env.SUPABASE_SERVICE_ROLE_KEY.substring(0, 5) + '...)' : 'Missing');
          
          const { data: emergencyInsert, error: emergencyError } = await supabase
            .from('orders')
            .insert(emergencyOrderData);
            
          if (emergencyError) {
            console.error('EMERGENCY INSERTION FAILED:', emergencyError);
          } else {
            console.log('EMERGENCY INSERTION SUCCEEDED!');
          }
        } catch (err) {
          console.error('EMERGENCY INSERTION EXCEPTION:', err);
        }
        // Continue with the rest of the webhook handler code
        
        // Extract necessary information
        const eventId = session.metadata?.eventId
        
        console.log('METADATA DEBUG:', session.metadata)
        console.log('EVENT ID FROM METADATA:', eventId)
        
        if (!eventId) {
          console.error('No event ID found in session metadata')
          return NextResponse.json({ error: 'Missing event ID in metadata' }, { status: 400 })
        }
        
        // Validate that the event ID is a valid UUID (important for foreign key constraint)
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        if (!uuidRegex.test(eventId)) {
          console.error(`Invalid event ID format: ${eventId} is not a valid UUID`)
          // Don't fail the webhook, but use a placeholder ID or null
          // We'll try to process the order anyway, just with a null event_id
          console.log('Will attempt to process order with null event_id')
        }
        
        // Record the order in Supabase using admin rights to bypass RLS
        console.log('💾 About to record order in Supabase')
        const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
        const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!
        
        console.log('Environment check:', {
          supabaseUrl: supabaseUrl ? 'Present' : 'Missing',
          serviceKey: supabaseServiceKey ? `Present (${supabaseServiceKey.substring(0, 5)}...)` : 'Missing'
        })
        
        
        // Create a supabase admin client with the service role key for webhook operations
        // Try to initialize Supabase client with error handling
        let supabase;
        try {
          supabase = createServerClient(
            supabaseUrl,
            supabaseServiceKey,
            {
              cookies: {
                get: () => undefined,
                set: () => {},
                remove: () => {}
              }
            }
          )
          console.log('Supabase client initialized successfully')
        } catch (supabaseInitError) {
          console.error('CRITICAL ERROR: Failed to initialize Supabase client:', supabaseInitError)
          return NextResponse.json({ error: 'Failed to initialize database client' }, { status: 500 })
        } => undefined,
              set: () => {},
              remove: () => {}
            }
          }
        )
        
        // Try to find the user ID based on the email
        let userId = null
        if (session.customer_details?.email) {
          const { data: userData } = await supabase
            .from('profiles')
            .select('id')
            .eq('email', session.customer_details.email)
            .single()
            
          if (userData) {
            userId = userData.id
            console.log(`Found user ID ${userId} for email ${session.customer_details.email}`)
          }
        }
        
        // Log the session details for debugging (excluding sensitive data)
        console.log('Session details:', {
          id: session.id,
          eventId,
          customer_email: session.customer_details?.email,
          customer_name: session.customer_details?.name,
          customer_phone: session.customer_details?.phone,
          amount_total: session.amount_total,
          quantity: session.metadata?.quantity,
        })
        
        // Check if customer_phone column exists in orders table
        const { data: columnCheck, error: columnError } = await supabase
          .from('information_schema.columns')
          .select('column_name')
          .eq('table_name', 'orders')
          .eq('column_name', 'customer_phone')
        
        if (columnError) {
          console.error('Error checking for customer_phone column:', columnError)
        } else {
          console.log(`customer_phone column ${columnCheck && columnCheck.length > 0 ? 'exists' : 'does not exist'} in orders table`)
        }
        
        // Prepare order data
        const orderData: Record<string, any> = {
          // Only set event_id if it's a valid UUID
          event_id: uuidRegex.test(eventId) ? eventId : null,
          stripe_session_id: session.id,
          customer_email: session.customer_details?.email,
          customer_name: session.customer_details?.name,
          // Store the amount in dollars (Stripe sends cents)
          amount_total: session.amount_total ? session.amount_total / 100 : 0,
          status: 'completed',
          quantity: parseInt(session.metadata?.quantity || '1'),
          user_id: userId, // Link to user profile if found
        }
        
        // If the event ID wasn't valid, store it in a metadata field for reference
        if (!uuidRegex.test(eventId) && eventId) {
          orderData.metadata = { original_event_id: eventId }
        }
        
        // Add customer_phone if the column exists
        if (columnCheck && columnCheck.length > 0) {
          orderData.customer_phone = session.customer_details?.phone
        }
        
        console.log('Attempting to insert order with data:', {
          ...orderData,
          stripe_session_id: orderData.stripe_session_id ? `${orderData.stripe_session_id.substring(0, 10)}...` : null
        })
        
        // Insert the order record
        console.log('ATTEMPTING DIRECT INSERT WITH SUPABASE SERVICE ROLE...')
        try {
          // Explicitly log and test Supabase connection before attempting insert
          const { data: testData, error: testError } = await supabase
            .from('orders')
            .select('id')
            .limit(1)
          
          if (testError) {
            console.error('SUPABASE CONNECTION TEST FAILED:', testError)
          } else {
            console.log('SUPABASE CONNECTION SUCCESSFUL, proceeding with insert')
          }
          
          const { data: insertData, error: orderError } = await supabase
            .from('orders')
            .insert(orderData)
            .select()
        
        if (orderError) {
            console.error('Error recording order:', orderError)
            console.error('Order data attempted to insert:', {
              ...orderData,
              stripe_session_id: orderData.stripe_session_id ? `${orderData.stripe_session_id.substring(0, 10)}...` : null
            })
            
            // Check if the error is related to a missing column
            if (orderError.message && orderError.message.includes('column')) {
              console.error('This appears to be a database schema issue. Please run the migration script in Supabase SQL editor.')
              console.error('Migration script path: migrations/add_customer_phone_to_orders.sql')
            }
          
            // Try again without the customer_phone field if that's causing the issue
            if (orderData.customer_phone && orderError.message && orderError.message.includes('customer_phone')) {
              console.log('Attempting to insert order without customer_phone field...')
              const retryOrderData = { ...orderData }
              delete retryOrderData.customer_phone
              
              const { error: retryError } = await supabase
                .from('orders')
                .insert(retryOrderData)
                
              if (retryError) {
                console.error('Second attempt to record order also failed:', retryError)
              
                // Last resort: try with only the minimal required fields
                console.log('Attempting final fallback with minimal data...')
                const minimalOrderData = {
                  event_id: eventId,
                  stripe_session_id: session.id,
                  amount_total: session.amount_total ? session.amount_total / 100 : 0,
                  status: 'completed',
                  quantity: parseInt(session.metadata?.quantity || '1')
                }
                
                const { error: minimalError } = await supabase
                  .from('orders')
                  .insert(minimalOrderData)
                  
                if (minimalError) {
                  console.error('All order recording attempts failed. Final error:', minimalError)
                  
                  // Emergency backup: Create a local log file with order details
                  try {
                    // We'll log this error in case we need to manually reconcile later
                    console.error('CRITICAL: FAILED TO RECORD ORDER WITH SESSION ID:', session.id)
                    console.error('All database attempts failed. Manual intervention required.')
                  } catch (e) {
                    console.error('Even logging failed:', e)
                  }
                  
                  return NextResponse.json({ error: 'Failed to record order' }, { status: 500 })
                } else {
                  console.log('Successfully recorded order with minimal data on final attempt')
                  // Continue with the rest of the function
                }
              } else {
                console.log('Successfully recorded order on second attempt (without customer_phone)')
                // Continue with the rest of the function
              }
            } else {
              // Try minimal data approach directly since it's not a customer_phone issue
              console.log('Attempting fallback with minimal data...')
              const minimalOrderData = {
                event_id: eventId,
                stripe_session_id: session.id,
                amount_total: session.amount_total ? session.amount_total / 100 : 0,
                status: 'completed',
                quantity: parseInt(session.metadata?.quantity || '1')
              }
              
              const { error: minimalError } = await supabase
                .from('orders')
                .insert(minimalOrderData)
                
              if (minimalError) {
                console.error('All order recording attempts failed. Final error:', minimalError)
                return NextResponse.json({ error: 'Failed to record order' }, { status: 500 })
              } else {
                console.log('Successfully recorded order with minimal data')
                // Continue with the rest of the function
              }
            }
          }
        } catch (err) {
          // Catch any unexpected errors in the Supabase client operations
          console.error('CRITICAL ERROR IN DATABASE OPERATIONS:', err)
          console.error('Order data that failed:', {
            ...orderData,
            stripe_session_id: orderData.stripe_session_id ? `${orderData.stripe_session_id.substring(0, 10)}...` : null
          })
          
          // Make one final attempt with a completely different approach
          try {
            console.log('ATTEMPTING EMERGENCY DIRECT INSERT WITH SIMPLIFIED DATA...')
            const emergencyData = {
              stripe_session_id: session.id,
              amount_total: session.amount_total ? session.amount_total / 100 : 0,
              status: 'completed'
            }
            
            const { error: emergencyError } = await supabase
              .from('orders')
              .insert(emergencyData)
              
            if (emergencyError) {
              console.error('Emergency insert also failed:', emergencyError)
              return NextResponse.json({ error: 'Database operations failed completely' }, { status: 500 })
            } else {
              console.log('Emergency insert succeeded!')
            }
          } catch (finalErr) {
            console.error('ALL INSERTION ATTEMPTS FAILED. Manual intervention required.')
            return NextResponse.json({ error: 'Critical database failure' }, { status: 500 })
          }
        }
        
        // Update ticket count for the event
        const quantity = parseInt(session.metadata?.quantity || '1')
        
        // First, verify that the event ID is valid and the event exists
        if (uuidRegex.test(eventId)) {
          console.log(`Attempting to update tickets for event: ${eventId}`)
          
          try {
            // First, get current tickets remaining
            const { data: eventData, error: fetchError } = await supabase
              .from('events')
              .select('tickets_remaining')
              .eq('id', eventId)
              .single()
            
            if (fetchError) {
              console.error('Error fetching event data:', fetchError)
              console.log('Will skip updating event ticket count due to error')
              // Don't fail the webhook, we've already recorded the order
            } else {
        
              // Calculate new tickets remaining
              const newTicketsRemaining = Math.max(0, eventData.tickets_remaining - quantity)
              const soldOut = newTicketsRemaining <= 0
              
              // Update the event
              const { error: eventError } = await supabase
                .from('events')
                .update({
                  tickets_remaining: newTicketsRemaining,
                  sold_out: soldOut
                })
                .eq('id', eventId)
              
              if (eventError) {
                console.error('Error updating event ticket count:', eventError)
                console.log('Order was recorded, but ticket count update failed')
                // Don't fail the webhook, we've already recorded the order
              } else {
                console.log(`Updated event ${eventId}: tickets_remaining=${newTicketsRemaining}, sold_out=${soldOut}`)
              }
            }
          } catch (eventUpdateError) {
            console.error('Error during event update process:', eventUpdateError)
            console.log('Order was recorded, but event update failed')
            // Don't fail the webhook, we've already recorded the order
          }
        } else {
          console.log('Skipping event update because event ID is not a valid UUID')
        }
        
        break
        
      default:
        console.log(`Unhandled event type: ${event.type}`)
    }
  } catch (error) {
    console.error('Error processing webhook:', error)
    return NextResponse.json({ error: 'Error processing webhook' }, { status: 500 })
  }
  
  // Return a response to acknowledge receipt of the event
  return NextResponse.json({ received: true })
}
